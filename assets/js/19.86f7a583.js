(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{513:function(t,e,a){"use strict";a.r(e);var o=a(6),r=Object(o.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("记录一些需求问题：主题换肤、axios封装、权限认证")]),t._v(" "),a("h2",{attrs:{id:"主题换肤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主题换肤"}},[t._v("#")]),t._v(" 主题换肤")]),t._v(" "),a("ol",[a("li",[t._v("样式覆盖")])]),t._v(" "),a("p",[t._v("利用css的优先级，将需要修改主题样式的className提取出来，定义不同的主题 使用[data-theme='blue']进行覆盖")]),t._v(" "),a("blockquote",[a("p",[t._v("缺点：样式不宜管理，效率低")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("使用css变量进行覆盖")])]),t._v(" "),a("p",[t._v("可以使用css3 的 var 。在root根目录下配置默认主题，使用[data-theme='blue']添加不同主题下的样式")]),t._v(" "),a("blockquote",[a("p",[t._v("缺点：兼容性问题，已有css-vars-ponyfill插件进行解决，以支持主流浏览器，支持到IE11")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用less/scss的mixin功能")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$color-light: {\n  bgColor: #336699,\n  text: #333\n}\n\n$color-dark: {\n  bgColor: #eeeeee,\n  text: #aaaaaa\n}\n\n@mixin bg-color() {\n  background-color: map-get($color-light, 'bgColor')\n  [data-theme=\"dark\"] & {\n    background-color: map-get($color-dark, 'bgColor')\n  }\n}\n\n@mixin text-color() {\n  color: map-get($color-light, 'text')\n  [data-theme=\"dark\"] & {\n    color: map-get($color-dark, 'text')\n  }\n}\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[t._v("通过编译配置，生成多个theme文件，在更换主题时，动态添加link")])]),t._v(" "),a("h2",{attrs:{id:"axios封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#axios封装"}},[t._v("#")]),t._v(" axios封装")]),t._v(" "),a("ol",[a("li",[t._v("初始化，可以使用axios.create({}), 也可以使用axios.defaults去改配置")])]),t._v(" "),a("p",[t._v("通常需要修改的配置时baseURL、timeout")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("添加拦截器")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("请求拦截器")]),t._v(" "),a("p",[t._v("一般用于在请求时获取用户的token，绑定到header上")])]),t._v(" "),a("li",[a("p",[t._v("响应拦截器")]),t._v(" "),a("p",[t._v("用于处理错误信息。判断错误码，编写相应的错误信息 如：400 -> 请求错误")])])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("封装get、post请求\n导出Get、POST两个方法，在POST方法中对传入的params使用qs.stringify进行序列化成URL的形式，目的是将请求参数形式变为form-data")])]),t._v(" "),a("h2",{attrs:{id:"权限认证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#权限认证"}},[t._v("#")]),t._v(" 权限认证")]),t._v(" "),a("ul",[a("li",[t._v("路由权限\n首先在编写路由时区分一下同步路由、异步路由、异常路由(404)。同步路由为没有权限要求，所有角色都可以访问的路由。异步路由是需要验证角色信息的路由，支持的角色名一般写在路由.meta.roles。在路由初始化时加载同步路由.concat(异常路由)即可。")])]),t._v(" "),a("p",[t._v("然后是设置路由的全局前置守卫，根据用户的token或是其他信息判断用户是否登录，没登陆就next()。登陆过的，根据vuex一个变量标识符，判断是否加载过该角色拥有的路由，为true表示加载过就next().没加载过，从登录后的用户信息中获取role，根据role去异步路由中按照路由.meta.roles是否含有用户的role筛选该用户角色的路由。然后需要对路由进行初始化，目的是去掉之前绑定的404路由，操作为\n"),a("code",[t._v("router.matcher = new Router({routes: 同步路由}).matcher")]),t._v("，这样之后路由就没有404了，然后就使用router.addRoutes去挂载筛选出来的符合权限的路由，修改vuex中的标识符为true，最后使用"),a("code",[t._v("next({path: to.path, replace: true})")]),t._v("，这是为了确保addRoutes已经完成加载，配置replace是为了覆盖当前的浏览记录")]),t._v(" "),a("ul",[a("li",[t._v("按钮级权限\n可以通过编写一个全局的自定义指令，传入该按钮支持的角色数组，在"),a("code",[t._v("inserted")]),t._v("是进行判断用户的角色是否在支持的数组里，不在就移除改dom")])])])}),[],!1,null,null,null);e.default=r.exports}}]);